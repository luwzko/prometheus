from prometheus.data_models.action import ActionRequest
from prometheus.data_models.responses import Plan, Reflection

from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any, Literal

class BaseContext(BaseModel): ...

class ActionOutput(BaseContext):
    source: Optional[str] = None
    variable: Optional[str] = None
    result: Any = None

class ModelOutput(BaseContext):
    content: str

class ExecutorContext(BaseModel):
    """
    Executor Context is practically the same class as Plan (generated by Planner agent)
    But it contains action_output.
    ExecutorAgent returns object of this class.
    """
    class ExecutionSteps(BaseModel):
        class ControlData(BaseModel):
            id: Optional[str] = None
            depends_on: Optional[List[str]] = None
            ref_output_as: Optional[str] = None

        message: Optional[str] = None
        intent: Optional[str] = None

        action_request: Optional[ActionRequest] = None
        action_output: Optional[ActionOutput] = None

        control: Optional[ControlData] = None

    executed: Optional[Dict[str, ExecutionSteps]] = Field(default_factory=dict)

    def add_step(self, execution_step: ExecutionSteps):
        key = execution_step.control.ref_output_as
        if key is None:
            raise ValueError("ExecutionStep.control.ref_output_as is None; cannot store in executed dict.")

        self.executed[key] = execution_step

    def __getitem__(self, item: str):
        return self.executed[item]

    def __iter__(self):
        return iter(self.executed)

class PrometheusOutput(BaseContext):
    mode: Optional[str] = None
    text: Optional[ModelOutput] = None

    action_output: Optional[ActionOutput] = None

    task: Optional[str] = None
    plan: Optional[Plan] = None

    executed: Optional[ExecutorContext] = None
    reflection: Optional[Reflection] = None