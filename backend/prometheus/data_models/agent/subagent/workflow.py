from pydantic import BaseModel, Field
from typing import Optional, List, Dict

from prometheus.data_models.action import ActionOutput, ActionRequest

class ControlData(BaseModel):
    """
    ControlData determines how steps depend on one another.
    ID - unique id of each step, generated by the model
    depends_on - IDs of steps which this specific step depends on
    ref_output_as - reference output as, variable name of current steps output
    """
    id: Optional[str] = None
    depends_on: Optional[List[str]] = None
    ref_output_as: Optional[str] = None

class PlannedWorkflow(BaseModel):
    """
    Workflow detailing which steps need to be taken using actions to achieve something.
    It's a list of PlanningSteps, each step is unique by `action_request` and `control`
    """
    class PlanningSteps(BaseModel):
        message: str | None = None
        intent: str | None = None

        action_request: ActionRequest
        control: ControlData

    plans: List[PlanningSteps]

    def __iter__(self):
        return iter(self.plans)

class ExecutedWorkflow(BaseModel):
    """
    ExecutedWorkflow is practically the same as PlannedWorkflow, but with action_output.
    It's the executed version of the planned one. This class is contained in PrometheusOutput.
    """
    class ExecutionSteps(BaseModel):
        message: Optional[str] = None
        intent: Optional[str] = None

        action_request: Optional[ActionRequest] = None
        action_output: Optional[ActionOutput] = None

        control: Optional[ControlData] = None

    executed: Optional[Dict[str, ExecutionSteps]] = Field(default_factory=dict)

    def add_step(self, execution_step: ExecutionSteps):
        key = execution_step.control.ref_output_as

        if key is None:
            raise ValueError("ExecutionStep.control.ref_output_as is None; cannot store in executed dict.")

        self.executed[key] = execution_step

    def __getitem__(self, item: str):
        return self.executed[item]

    def __iter__(self):
        return iter(self.executed)
